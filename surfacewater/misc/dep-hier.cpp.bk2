//#include "Array2D.hpp"
#include <richdem/common/Array2D.hpp>
#include <richdem/common/grid_cell.hpp>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <stdexcept>
#include <string>
#include <utility>

constexpr double SQ2 = std::sqrt(2.0);

using namespace richdem;

//1 2 3
//0   4
//7 6 5
//                      0  1  2  3 4 5 6  7
const int dx8[8]       = {-1,-1, 0, 1,1,1,0,-1};
const int dy8[8]       = {0, -1,-1,-1,0,1,1, 1};
const double dr8[8]    = {1,SQ2,1,SQ2,1,SQ2,1,SQ2};
const int d8inverse[8] = {4,  5, 6, 7,0,1,2, 3};

//  1
//0   2
//  3
//                      0  1 2 3
const int dx4[8]       = {-1, 0,1,0};
const int dy4[8]       = { 0,-1,0,1};
const double dr4[4]    = { 1, 1,1,1};
const int d4inverse[4] = { 2, 3,0,1};

const int    *const mdx      = dx8;
const int    *const mdy      = dy8;
const int    *const dinverse = d8inverse;
const double *const mdr      = dr8;
const int neighbours         = 8;


const float  OCEAN_LEVEL = 0;
const int8_t NO_FLOW     = -1;

class mGridCellZk {
 public:
  int x, y;
  float z;
  mGridCellZk(const int x0, const int y0, const float z0){
    x = x0;
    y = y0;
    z = z0;
  }
  bool operator>(const mGridCellZk& a) const {
    return z>a.z; //Less than sorts the queue in reverse
  }
};

//Identifier for cells which are not part of a depression
const int NO_PARENT = -3;
const int NO_DEP    = -2;
const int OCEAN     = -1;


class Depression {
 public:
  typedef int label_t;
  int     out_cell = -1;
  double  out_elev = std::numeric_limits<double>::infinity();
  int     pit_cell = -1;
  double  pit_elev = std::numeric_limits<double>::infinity();
  label_t parent   = NO_PARENT;
  std::vector<label_t> children;
};



int ModFloor(int a, int n) {
  return ((a % n) + n) % n;
}

template<class T>
void WrapCoordinates(const Array2D<T> &arr, int &nx, int &ny){
  nx = ModFloor(nx,arr.width());
}



//Cells label their neighbours as they are processed. Some of these neighbours
//may be at the top of high cliffs. By the time the neighbours are finally
//processed themselves an outlet may have been found for the depression they
//were part of. In this case, they are actually part of the meta-depression
//formed by the depressions linked by that outlet. Since this merging of
//depressions may have happened several times, we need to follow the chain of
//depressions upward until we find the true parent.
int GetParentLabel(const std::vector<Depression> &depressions, int label, const float elev){
  //All depressions are labeled [0,*). If the label is less than zero then the
  //depression is either part of the ocean, has no parent, or is not yet a
  //depression. Regardless, we can simply return the label.
  if(label<0)
    return label;

  //If we find the ocean, we stop: the ocean will be our new label. If we
  //discover that the depression has no parent, we stop: this depression must
  //be our parent. If our elevation is less than the spill elevation of the
  //depression, then we are not part of its meta-depression.
  while(
       label!=OCEAN                             //Stop if we find we are already linked to the ocean
    && depressions.at(label).parent!=NO_PARENT  //Stop if we have no parent (we have not yet found the ocean)
    && elev>=depressions.at(label).out_elev     //Stop if we are lower than the outlet of the depression (this depression is our parent)
  ){
    std::cerr<<"Upgrading label. label="<<label<<" parent="<<depressions.at(label).parent<<" elev="<<elev<<" depelev="<<depressions.at(label).out_elev<<std::endl;
    label = depressions.at(label).parent;       //Continue up the chain of depressions. Perhaps we are part of this depression's metadepression?
  }

  return label;
};



void MergeDepressions(
  const Array2D<float>    &topo,
  std::vector<Depression> &depressions,
  Array2D<int>            &label,
  int cidx,
  int nidx
){
  std::cerr<<"Attempting to merge "<<(cidx%topo.width())<<","<<(cidx/topo.width())<<" ("<<label(cidx)<<") with "<<(nidx%topo.width())<<","<<(nidx/topo.width())<<" ("<<label(nidx)<<")"<<std::endl;
  if(label(cidx)==OCEAN || label(nidx)==OCEAN){
    if(label(nidx)!=OCEAN) 
      std::swap(cidx,nidx);

    const auto clabel = label(cidx);

    //cidx is the depression that has found the ocean
    auto &cdep     = depressions.at(clabel);

    if(cdep.parent!=NO_PARENT){           //Already found an outlet
      std::cerr<<"\tOcean merged failture, parent="<<cdep.parent<<std::endl;
      return;
    }

    std::cerr<<"\tOcean"<<std::endl;

    auto out_elev = topo(nidx);
    auto out_cell = nidx;
    if(topo(nidx)<topo(cidx)){
      out_cell = cidx;
      out_elev = topo(cidx);
    }
    cdep.out_cell = out_cell;
    cdep.out_elev = out_elev;
    cdep.parent   = OCEAN;
  } else {              //Merging of two depressions
    if(label(cidx)<0)
      std::swap(cidx,nidx);

    const auto clabel = label(cidx);
    const auto nlabel = label(nidx);    
    auto &cdep = depressions.at(clabel);
    auto &ndep = depressions.at(nlabel);

    //If both depressions already have an outlet or one depression is already
    //the parent of the other, then don't merge them.
    if(
         (cdep.parent!=NO_PARENT && ndep.parent!=NO_PARENT)
      || (cdep.parent!=NO_PARENT && cdep.parent==ndep.parent)
      || cdep.parent==nlabel
      || ndep.parent==clabel
    ){
      std::cerr<<"\tNon parent merge failure."<<std::endl;
      return;
    }

    std::cerr<<"\tMerged "<<clabel<<" (e="<<topo(cidx)<<", p="<<depressions.at(clabel).parent<<") and "<<nlabel<<" (e="<<topo(nidx)<<", p="<<depressions.at(nlabel).parent<<")"<<std::endl;

    auto out_elev = topo(nidx);
    auto out_cell = nidx;
    if(topo(nidx)<topo(cidx)){
      out_cell = cidx;  
      out_elev = topo(cidx);
    }

    const auto newlabel = depressions.size();
    label(out_cell)     = newlabel; //Actually, any cell touched by n which is of equal elevation, so take this with many grains of salt
    std::cerr<<"\tChanged label of cell in dep merge."<<std::endl;

    assert(ndep.parent<0);    
    ndep.parent   = newlabel;
    ndep.out_elev = out_elev;
    ndep.out_cell = out_cell;

    assert(cdep.parent<0);
    cdep.parent   = newlabel;
    cdep.out_elev = out_elev;
    cdep.out_cell = out_cell;  

    std::cerr<<"New depression from merge "<<newlabel<<std::endl;
    auto &newdep    = depressions.emplace_back();
    newdep.children.push_back(nlabel);
    newdep.children.push_back(clabel);
    newdep.pit_cell = out_cell;
    newdep.pit_elev = out_elev;
  }
}



std::vector<Depression> GetDepressionHierarchy(const Array2D<float> &topo, Array2D<int> &label){
  //Depressions are identified by a number [0,*). This vector holds the
  //depressions.
  std::vector<Depression> depressions;

  //The priority queue ensures that cells are visited in order from lowest to
  //highest. Cells of equal elevation that are added to the queue later are
  //processed before cells that were added earlier.
  GridCellZk_high_pq<float> pq;

  //Ensure that all cells are initially labeled as being not part of a
  //depression.
  label.setAll(NO_DEP);



  //We start by adding all the edge cells to the priority queue. We label these
  //edge cells as ocean. Note that if a landmass were to intersect the edges of
  //the DEM, this may lead to incorrect results. The user should find a way of
  //identifying what they consider to be the ocean/base-level (if any) and
  //modify this portion of the code to identify it.
  for(int y=0;y<topo.height();y++){
    pq.emplace(0,               y,topo(0,             y)); 
    pq.emplace(topo.width()-1,  y,topo(topo.width()-1,y)); 
    label(0,               y) = OCEAN;
    label(topo.width()-1,  y) = OCEAN;    
  }
  for(int x=0;x<topo.width();x++){
    pq.emplace(x, 0,               topo(x,               0)); 
    pq.emplace(x, topo.height()-1, topo(x, topo.height()-1)); 
    label(x, 0              ) = OCEAN;
    label(x, topo.height()-1) = OCEAN;    
  }

  //Here we find the pit cells of internally-draining regions. We define these
  //to be cells without any downstream neighbours. Note that this means we will
  //identify all flat cells as being pit cells. For DEMs with many flat cells,
  //this will bloat the priortiy queue slightly. If your DEM includes extensive,
  //predictably located flat regions, you may wish to add these in some special
  //way. Alternatively, you could use Barnes (2014, "An Efficient Assignment of
  //Drainage Direction Over Flat Surfaces") as a way of reducing the number of
  //flat cells. Regardless, the algorithm will deal gracefully with the flats it
  //finds.
  for(int y=1;y<topo.height()-1;y++)
  for(int x=1;x<topo.width() -1;x++){
    const auto my_elev = topo(x,y);
    bool has_lower     = false;
    for(int n=0;n<neighbours;n++){
      const int nx = x+dx[n];
      const int ny = y+dy[n];
      if(topo(nx,ny)<my_elev){
        has_lower = true;
        break;
      }
    }
    //The cell can't drain
    if(!has_lower)
      pq.emplace(x,y,topo(x,y)); 
  }

  //Visit cells in order from lowest to highest
  while(!pq.empty()){
    const auto c = pq.top();                //Copy cell with lowest elevation from priority queue
    pq.pop();                               //Remove the copied cell from the priority queue
    const auto celev = c.z;                 //Elevation of focal cell
    const auto ci    = topo.xyToI(c.x,c.y); //Flat-index of focal cell
    auto clabel      = label(ci);           //Nominal label of cell

    std::cerr<<std::endl;
    std::cerr<<"Popping "<<c.x<<" "<<c.y<<" label="<<clabel<<" clev="<<celev;
    if(clabel>=0)
      std::cerr<<" cparent="<<depressions.at(clabel).parent;
    std::cerr<<std::endl;

    auto prevlabel = clabel;
    if(clabel==OCEAN){
      //This cell is an ocean cell or a cell that flows into the ocean without
      //encountering any depressions on the way. Upon encountering it we do not
      //need to do anything special.
    } else if(clabel==NO_DEP){
      //Since cells label their neighbours and ocean cells are labeled in the
      //initialization, the only way to get to a cell that is still labeled as
      //not being part of a depression is if that cell were added as a pit cell.
      //For each pit cell we find, we make a new depression and label it
      //accordingly. Not all the pit cells originally added will form new
      //depressions as flat cells will relabel their neighbours.
      clabel          = depressions.size();         //In a 0-based indexing system, size is equal to the id of the next flat
      auto &newdep    = depressions.emplace_back(); //Add the next flat (increases size by 1)
      newdep.pit_cell = topo.xyToI(c.x,c.y);        //Make a note of the pit cell's location
      newdep.pit_elev = celev;                      //Make a note of the pit cell's elevation
      label(ci)       = clabel;                     //Update cell with new label
      std::cerr<<"\tNew depression from pit cell with label = "<<clabel<<" at "<<c.x<<" "<<c.y<<std::endl;
    } else {
      //It may be that this cell was added by a lower cell which was in a
      //depression. We may have since found the outlet for that depression, so
      //we need to find this cell's parent.
      //TODO: Acclerate this with caching
      clabel = GetParentLabel(depressions, clabel, celev);
      label(ci) = clabel;                           //Update cell with new label, if any
      std::cerr<<"\tSet label to = "<<clabel;
      if(clabel>0){
        std::cerr<<" parent = "<<depressions.at(clabel).parent;
      }
      std::cerr<<std::endl;
    }
    if(prevlabel!=clabel){
      std::cerr<<"\tChanged label of cell in parent check."<<std::endl;
    }

    //Consider the cell's neighbours
    for(int n=0;n<neighbours;n++){
      std::cerr<<"-n-"<<std::endl;
      int nx = c.x + mdx[n];              //Get neighbour's coordinates using an offset
      int ny = c.y + mdy[n];              //Get neighbour's coordinates using an offset
      WrapCoordinates(topo,nx,ny);        //Wrap coordinates around torous
      if(!topo.inGrid(nx,ny))             //Is this a valid cell?
        continue;                         //Neighbour cell is out of bounds
      const auto ni    = topo.xyToI(nx,ny);
      const auto nelev = topo(ni);        //Elevation of neighbour cell
      //Make sure we're looking at the most recent view of n
      const auto nlorig = label(ni);
      const auto nlabel = GetParentLabel(depressions, label(ni), nelev);
      label(ni)         = nlabel;
      if(nlabel!=nlorig){
        std::cerr<<"\tChanged label of ncell in parent check."<<std::endl;
      }

      std::cerr<<"Considering neighbour "<<nx<<" "<<ny<<" label="<<nlabel<<" nelev="<<nelev;
      if(nlabel>=0)
        std::cerr<<" parent="<<depressions.at(nlabel).parent;
      std::cerr<<std::endl;

      //If the neighbour and I are in the same depression, there's nothing to
      //do. I don't add the neighbour to the priority queue because every cell
      //is labeled by the time it is added to the queue, so the fact that my
      //neighbour has a label indicates that it's been in the queue.
      if(nlabel==clabel)                  
        continue;

      if(nlabel==NO_DEP){                 //Neighbour has not been visited yet
        label(ni) = clabel;               //Give the neighbour my label
        std::cerr<<"\tChanged label of cell in standard expansion."<<std::endl;
        pq.emplace(nx,ny,nelev);          //Add the neighbour to the priority queue
      } else {
        MergeDepressions(topo, depressions, label, ci, ni);
      }
    }

  if(label.width()<1000)
  for(int y=0;y<label.height();y++){
    for(int x=0;x<label.width();x++)
      std::cerr<<std::setw(3)<<topo(x,y)<<" ";  
    std::cerr<<"    ";  
    for(int x=0;x<label.width();x++)
      std::cerr<<std::setw(3)<<label(x,y)<<" ";
    std::cerr<<std::endl;
  }

  }

  return depressions;
}






int main(int argc, char **argv){
  if(argc!=4){
    std::cerr<<"Syntax: "<<argv[0]<<" <Input> <Output> <OutGraph>"<<std::endl;
    return -1;
  }

  std::string in_name   = argv[1];
  std::string out_name  = argv[2];
  std::string out_graph = argv[3];

  Array2D<float> dem(in_name);   //Recharge (Percipitation minus Evapotranspiration)

  Array2D<Depression::label_t> label(dem,NO_DEP);
  auto deps = GetDepressionHierarchy(dem, label);

  if(label.width()<1000)
  for(int y=0;y<label.height();y++){
    for(int x=0;x<label.width();x++)
      std::cout<<std::setw(3)<<label(x,y)<<" ";
    std::cout<<std::endl;
  }

  std::ofstream fgraph(out_graph);
  fgraph<<"digraph {\n";
  for(unsigned int i=0;i<deps.size();i++)
    fgraph<<i<<" -> "<<deps[i].parent<<";\n";
  fgraph<<"}\n";

  label.saveGDAL(out_name);

  return 0;
}
