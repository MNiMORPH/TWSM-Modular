//#include "Array2D.hpp"
#include <richdem/richdem.hpp>
#include <algorithm>
#include <cassert>
#include <cmath>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <map>
#include <queue>
#include <stdexcept>
#include <string>
#include <utility>

constexpr double SQ2 = std::sqrt(2.0);

using namespace richdem;

//1 2 3
//0   4
//7 6 5
//                      0  1  2  3 4 5 6  7
const int dx8[8]       = {-1,-1, 0, 1,1,1,0,-1};
const int dy8[8]       = {0, -1,-1,-1,0,1,1, 1};
const double dr8[8]    = {1,SQ2,1,SQ2,1,SQ2,1,SQ2};
const int d8inverse[8] = {4,  5, 6, 7,0,1,2, 3};

//  1
//0   2
//  3
//                      0  1 2 3
const int dx4[8]       = {-1, 0,1,0};
const int dy4[8]       = { 0,-1,0,1};
const double dr4[4]    = { 1, 1,1,1};
const int d4inverse[4] = { 2, 3,0,1};

const int    *const mdx      = dx8;
const int    *const mdy      = dy8;
const int    *const dinverse = d8inverse;
const double *const mdr      = dr8;
const int neighbours         = 8;


const float  OCEAN_LEVEL = 0;
const int8_t NO_FLOW     = -1;

class mGridCellZk {
 public:
  int x, y;
  float z;
  mGridCellZk(const int x0, const int y0, const float z0){
    x = x0;
    y = y0;
    z = z0;
  }
  bool operator>(const mGridCellZk& a) const {
    return z>a.z; //Less than sorts the queue in reverse
  }
};

class Depression {
 public:
  typedef int label_t;
  int     spill_cell      = -1;
  double  spill_elevation = std::numeric_limits<double>::infinity();
  int     pit_cell        = -1;
  double  pit_elevation   = std::numeric_limits<double>::infinity();
  label_t parent          = -1;
  std::vector<label_t> children;
};



int ModFloor(int a, int n) {
  return ((a % n) + n) % n;
}

template<class T>
void WrapCoordinates(const Array2D<T> &arr, int &nx, int &ny){
  nx = ModFloor(nx,arr.width());
}



Array2D<int> GetDepressionHierarchy(const Array2D<float> &topo){
  //Indicates whether a cell has previously been processed by the algorithm.
  //This prevents the algorithm from going in an infinite loop.
  Array2D<bool> processed(topo.width(),topo.height(),false);

  //Indicates whether or not the current path is ascending or descending.
  //Ascending paths start new depressions. Descending paths extend existing
  //ones.
  Array2D<bool> ascending(topo.width(),topo.height(),false);

  //Depressions are identified by a number [0,*). This vector holds the
  //depressions.
  std::vector<Depression> depressions;

  //Identifier for cells which are not part of a depression
  const Depression::label_t NO_DEP = -1;

  Array2D<Depression::label_t> label(topo,NO_DEP);

  //Label to apply to the next new depression we find
  Depression::label_t next_dep_label = 0;

  //The priority queue ensures that cells are visited in order from lowest to
  //highest
  GridCellZk_high_pq<float> pq;

  //We start by adding all the edge cells to the priority queue
  for(int y=0;y<topo.height();y++){
    pq.emplace(0,               y,topo(0,             y)); ascending(0,               y) = true;
    pq.emplace(topo.width()-1,  y,topo(topo.width()-1,y)); ascending(topo.width()-1,  y) = true;
  }
  for(int x=0;x<topo.width();x++){
    pq.emplace(x, 0,               topo(x,               0)); ascending(x, 0              ) = true;
    pq.emplace(x, topo.height()-1, topo(x, topo.height()-1)); ascending(x, topo.height()-1) = true;
  }

  //Visit cells in order from lowest to highest generating
  while(!pq.empty()){
    const auto c = pq.top();       //Copy cell with lowest elevation from priority queue
    pq.pop();                      //Remove the copied cell from the priority queue
    const auto celev  = topo(c.x,c.y);
    const auto clabel = label(c.x,c.y);

    Depression::label_t new_dep_label = -1;

    for(int n=0;n<neighbours;n++){
      int nx = c.x + mdx[n];        //Get neighbour's coordinates using an offset
      int ny = c.y + mdy[n];        //Get neighbour's coordinates using an offset
      WrapCoordinates(topo,nx,ny); //Wrap coordinates around torous
      if(!topo.inGrid(nx,ny))      //Is this a valid cell?
        continue;                  //Neighbour cell is out of bounds
      if(processed(nx,ny))         //Have we previously added this cell to the priority queue?
        continue;                  //Yes

      if(topo(nx,ny)<celev){         //This neighbour is in a depression
        //Since we were going up and the neighbour is down, this is a new
        //depression. Note that a cell can spawn more than one depression and
        //that these depressions, while initially separate, may later be joined.
        if(ascending(c.x,c.y)){  
          Depression *dep = NULL;
          if(new_dep_label==-1){
            dep           = &depressions.emplace_back();
            new_dep_label = next_dep_label++;
          } else {
            dep           = &depressions.back();
          }
          label(nx,ny)             = new_dep_label;
          dep->spill_elevation   = celev;
          dep->spill_cell        = topo.xyToI(c.x,c.y);
          dep->parent            = clabel;
          // std::cout<<"New depression at "<<nx<<" "<<ny<<" from "<<c.x<<" "<<c.y<<". celev="<<celev<<", nelev="<<topo(nx,ny)<<". Spill elev="<<dep->spill_elevation<<", parent="<<dep->parent<<std::endl;
          if(clabel!=NO_DEP)
            depressions[clabel].children.emplace_back(new_dep_label);
          ascending(nx,ny) = false;
        } else {                     //Since we were aleady going down, this neighbour simply extends the depression we were already in.
          label(nx,ny)     = label(c.x,c.y);
          ascending(nx,ny) = false;
        }
      } else if (topo(nx,ny)==celev) { //Move across a flat. We keep doing whatever we were doing.
        label(nx,ny)     = clabel;
        ascending(nx,ny) = ascending(c.x,c.y);
      } else {                          //Going up, possibly leaving a depression
        const auto nelev = topo(nx,ny); //Elevation of the neighbour

        //Find the neighbour's label. It will either be the label of the current
        //cell or, if the neighbour is higher than the spill elevation of the
        //depression the current cell belongs to, it will be the label of the
        //depression containing that depression.
        Depression::label_t nlabel = clabel;

        // std::cout<<"Considering switching label while climbing from "<<c.x<<" "<<c.y<<" ("<<celev<<") to "<<nx<<" "<<ny<<" ("<<nelev<<") with clabel="<<clabel<<std::endl;

        //`nlabel!=-1` handles the case where we've climbed out of all the
        //depressions and are merrily climbing a mountain. It also handles the
        //case where we've climbed out of all of the depressions.
        if(nlabel!=-1){
          // std::cout<<"\tSpill elevation of "<<nlabel<<" is "<<depressions[nlabel].spill_elevation<<std::endl;
        }
        while(nlabel!=-1 && depressions[nlabel].spill_elevation<nelev){
          // std::cout<<"\tSpill elevation of "<<nlabel<<" is "<<depressions[nlabel].spill_elevation<<std::endl;
          nlabel = depressions[nlabel].parent;
        }

        if(nlabel!=clabel){ //TODO
          // std::cout<<"Switching label from "<<clabel<<" to "<<nlabel<<" from "<<c.x<<" "<<c.y<<" to "<<nx<<" "<<ny<<std::endl;
        }

        //We were going down and now we're about to go up, so this is a pit
        //cell. We need to make sure it's the lowest pit cell, though, since on
        //our way in we added other cells to the priority queue before we found
        //the pit cell, so they will have `ascending=false` even though we are
        //on our way out.
        if(!ascending(c.x,c.y) && celev<depressions[clabel].pit_elevation){
          depressions[clabel].pit_cell      = topo.xyToI(c.x,c.y);
          depressions[clabel].pit_elevation = celev;
        }

        label(nx,ny)     = nlabel;
        ascending(nx,ny) = true;
      }

      processed(nx,ny) = true;
      pq.emplace(nx,ny,topo(nx,ny));
    }
  }

  //TODO: Need to deal with special cases in testdem10.dem
  // std::unordered_map<

  return label;
}






int main(int argc, char **argv){
  if(argc!=3){
    std::cout<<"Syntax: "<<argv[0]<<" <Input> <Output>"<<std::endl;
    return -1;
  }

  std::string in_name  = argv[1];
  std::string out_name = argv[2];

  Array2D<float> dem(in_name);   //Recharge (Percipitation minus Evapotranspiration)

  auto label = GetDepressionHierarchy(dem);

  if(label.width()<1000)
  for(int y=0;y<label.height();y++){
    for(int x=0;x<label.width();x++)
      std::cout<<std::setw(3)<<label(x,y)<<" ";
    std::cout<<std::endl;
  }

  label.saveGDAL(out_name);

  return 0;
}
